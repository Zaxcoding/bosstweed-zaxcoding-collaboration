{
Zach - 6/4/12

OH GOD YES THIS IS AWESOME!

Haha, so the big change is piece to piece collision detection. I'll get to it.

Piece.java:
Added pieceCollision(GameBoard board), a method used to check piece-piece 
collision detection. It's actually really simple. It just looks where the 
piece is (going to be, since you call it in the middle of a temporary gridX++
or gridY++ call, etc) and see if there are any non translucent-pieces there.
The tricky part was figuring out that you can't have the piece filled- you 
have to eraseTrail before checking or else you pick up your own piece. Once
I rearranged the order of some stuff in Tetris, it worked perfectly!

I also added a cool way to visualize the board for debugging, kinda based off
of Ramirez's MyRectangle visualization.

Tetris.java:
I did some reordering as I mentioned above. I really didn't write any new code 
except I fill in the board.grid with translucent when I call initBoard() and I 
also set the hardcoded filepath to a relative one ("Tetronimoes/J.png" etc).

And that's really it! Again it was a case of having all the pieces (pun) there
and just figuring out how to use them together (and in the right order) to
make the finished product.
}

{
Andy - 6/4/12

Next piece images are functional

Tetris.java- so the rng is basically using next piece now instead of 
currpiece, so that we can keep track of the image to be displayed. when we 
need a new piece, currpiece = next piece, and we pick a next piece. pretty 
sweet. only problem right now that i can think of is that i have hardcoded the 
image locations to my local desktop, you are probably more experienced than me 
about how to define the path so that we can both use it without hardcoding the 
path every time, but for now i just have them on my desktop and I'm assuming 
you can put them there as well, and just change /beersandrew/ in the path to 
whatever your macbook is registered under. 

Tetrominoes Folder - holds all the .png images for the pieces.



If piece -piece collision gets done today we are seriously on a roll! good luck :)
}

{
Zach - 6/3/12

Not going to do as big of a push, but I've done a little work so I'll put it
up. I added canRotateL() and canRotateR(). With this it won't let you rotate
out of the left side of the screen. If we want we can change this to add wall
kicking or whatever it's called so that it pushes you out if you rotate too
close to the wall.

Now there's really nothing standing in the way of trying to implement piece to
piece collision detection. I'm going to start on it tomorrow because my quick
try didn't work and I want to remain positive with today.

Oh, I also cut the timing in half to speed it up a bit for debugging.

}

{
Andy - 6/3/12

Big day for boss coding today, just got some timing down.

Tetris.java - The timing starts initially with the starting of the program, 
and every full second the piece is moved down one spot. I couldn't get 
stability in the timing using tenths or hundreds of a second the time would go 
like 12.9999999999985 and it looked really dumb so, full seconds is what we 
got right now. Also fixed the hard drop so that it does hard drop, potential 
problem of if you keep holding down the spacebar it kind of spawns the piece 
at the bottom. it looks really sweet right now though!

}

{
Zach - 6/3/12

GameBoard.java:
Added eraseTrail, which just colors over the current Piece's position with 
the same black as the background. Then, if it the user hits a movement key 
then the piece's position will be redrawn. This way we don't have to clear the
board completely each time, so multiple pieces can now be spawned without
issues! Woohoo! It's pretty cool!
Ps, eraseTrail is nearly verbatim your fill method, with a different color.
Inefficient to copy and paste, but much easier to read than adding an argument
to fill() to choose the color to fill with, I think.

_Piece.java:
Erased the canMoveDown, canMoveLeft, and canMoveRight methods because...

Piece.java:
I added them here! I found a generic way to collision detect with the boundary 
walls. I loop through the piece's grid until I find a filled in spot. First, I
do the move (gridX--, gridX++, or gridY++), then I go through all of the 
piece's filled in spots and test with that new grid coordinate to see if I'm
out of bounds anywhere. If so, return false. It works really really well! The
only issue I'm having is if you press up to the far left edge of the screen 
and then rotate, instead of wall-kicking it can push you out of bounds. You
can still come back in bounds- no exception occurs, because I don't test
in the GameBoard fill and eraseTrails method to make sure I don't draw out
of the array's bounds.

It's pretty neat and a simple to add feature! Things are coming along well!

Also, I think we can use the general idea I used here for canRotateR,
canRotateL, and also adding collision detecting between pieces!
}

{
Zach - 6/3/12

So this is a pretty awesome step towards a working product, but it's limited
in a few key areas. The main idea is that it only works for currPiece, and has
no idea about how to store the pieces/display multiple pieces/etc. I do have a
plan on how to implement multiple pieces, but for now I just want to document
this so we have something easy to fall back on if we lose our place.

An example of where it falls short is it resets the entire GameBoard when it 
calls clearBoard(). We'll have to change this to just clearPiece() to get rid
of the current piece's ghost trail.

GameBoard.java:
Really just did some formatting adjustments. The logic was all there. There 
was a single 1-off error but otherwise you nailed it. That fill() method was
really awesome to see work. Took out some of the debug info I had added.

Tetris.java:
Removed a lot of the stuff that I didn't use (mostly timing) and cleaned a few
things up. From top to bottom:

selectPiece(int a) - changed this to return a Piece instead of being void(), 
so that we can hopefully use it for the preview pieces and maybe other things.

Made the gamePanel focusable and set it to grabFocus most of the time a button
is pushed. This should keep the user able to use the keyboard without having 
to re-click the panel to select it. We'll have to adjust this for pausing.

Initialize the Random rng in setup and make it a global variable in case we 
want to get some randInt()s other places.

colorPieces(), initBoard(), clearBoard() - these are really easy, just for
loops that set the appropriate spots to the appropriate color.

MyListener - this is where all of the keyboard controls went.

I also went through and cleared out some old comments where we both know 
what's going on, and I added some comments where I wrote new code.

Good stuff! More features to come now!
}

{
Andy - 6/2/12

Yay for getting back in the swing of things.(get the swing pun?! ;) ) 

Tetris.java - set up a timing loop, that works until i hit start game, I'm not 
sure how to keep a loop going after the action listener occurs, maybe it ends 
because theres an exception with the button? I'm not sure but I'm pretty happy 
that the loop repeats

-Secondly attempted to set the current piece as a randomly selected piece. I 
did this with a new method in tetris called selectPiece, which is called when 
the boolean new piece is true.(not sure what the conditions are for this yet, 
we'll have to look into it and decide exactly 'when' we need to spawn a new 
piece).

.*Piece- apparently each individual piece class needs to import the color 
package, i assumed it was ok with what you had, but when i created individual 
pieces in tetris.java with selectPiece, none of the pieces compiled, so i 
added them. 

TPiece.java - PURPLE does not exist in the color package, so we'll have to 
settle for MAGENTA.
}

{
Zach - 5/31/12

Been a little while since I've programmed at all. Whoops. Here's what I've
done so far today.

GameBoard.java:
Just fixed a single line so that it would compile. Made a silly mistake.

Tetris.java:
Put in a lot of good work on the preferences panel. I added an array of keys,
which are just ints (each filled with a KeyEvent.KeyCode), and tempKeys, and
implemented a simple 'click-the-button-then-press-the-key' way to change the
control scheme. It's simple but also pretty comprehensive since it checks for
duplicates (and won't let you save if you have them), and also prompts you to
save your changes before closing the menu if tempKeys differs from Keys.
I like it, it works very well, but I'm going to go in next and add a feedback
label so you can tell what's going on (if you aren't a dev on this game).
}

{
Zach - 5/22/12

Tetris.java:
Changed the functionality of the pause button to start at 'Start Game', then
change to 'Pause' or 'Resume' according to what it should be. 
Added a colorPieces method that should loop through and display the pieces
with their correct colors.

GameBoard.java:
Adjusted the for loop on one because it said j<y<j++.
Also, and this is pretty cool if it'll work, I changed the number we're
filling with into the big grid from 1 (for all pieces) to piece.getRGB(). My
reasoning is that once we do this we can just loop through and color all the
non-zero values of the grid, with their values. I think this should work. 

I have to go right now, I'll update this with more and also code some more 
after I work out. See ya.
}

{
Andy - 5/21/12

ok lots to tell about, not a whole lot of new code though.

Tetris.java- made the game initially paused, so that the player doesn't open 
up the game to a falling piece, unease = start game..

Piece.java, *Piece.java- put in a primitive version of canmoveleft and 
canmoveright

The big oneâ€¦
Gameboard.java- attempted to implement an idea of how i think fill should 
work. I put in a 6 line comment or so above my weird for loop structure thing 
to attempt to explain what i did. This is all off of your idea of the grid 
over the game board, and the way i drew it out on my paper i think it works, 
or does what you had in mind.Please feel free to check it out and even dismiss 
it if its totally wrong

My only concerns are when, in the case of the O piece, where there are 0's in 
the piece grid itself, i think this means the canmoveleft and canmoveright 
need much more logic than my initial attempt, and there is need for the 
contact() method for both canmoveright and fill.

it seems there is still the entire piece logic to go yet, as far as how the 
pieces stay in the game board, and how pieces can freely fall and coexist on a 
board with an arbitrary amount of pieces already on the game board.
}

{
Zach - 5/20/12
Okay, I like your ideas but I'm going to shift the direction a bit.

I'm going to make the vast majority of the work be done in Piece.java. I want
very little- mostly only spawn() and setPiece()- to be different in each
_Piece file. That way we have less to type, less lines total, and more 
importantly we can access all of the methods for the pieces just through 
a Piece variable. Then our call to rotate() will choose the correct rotate()
based on the type of the piece.
Also, remember that you don't need to use the accessors when we're working in 
_Piece files, since we have direct access to the instance variables. Those 
kinds of getPosition() and getGridSize() calls will be done from the GameBoard
or Tetris files. 

Another big change:
A lot of your pieces had an empty top row and column. From poking around the
Tetris wiki I found that only the I and O pieces require gridSize = 4, the
rest can be done with gridSize = 3. I fixed all but I and O to have gridSize 3
and adjusted them so that they work in that space.
Additionally, I subtracted 1 from each of the [3][2] combos because 2d arrays
start at 0,0 not 1,1 (my Yahtzee arrays are a little funky if that's where you
got that idea). We can change it back if you like but for now they're 
consistent.

So here's what I did:
Tetris.java:
Changed the JPiece j = new JPiece(), LPiece... to Piece j = new JPiece() etc
just to test it out. I also did a test run of rotateL() through the Piece
variable (not, for example, JPiece variable) and had no problems.

Piece.java:
Added a constructor that sets position = 1 and calls spawn().
Moved all of the rotate() calls from the individual files to here. I trimmed 
down the work that's done, all it does is clear the grid, set position to the
new position, and then call setPiece(). I also added the modulo math thing
that I had mentioned earlier so that we don't have to have four different
if(d==1) setPiece(2,..) calls, we just call setPiece(). You'll also notice
that setPiece no longer takes any arguments- I'll get to that in a bit.
I adjusted clearGrid so it does so based on the gridSize, not just a fixed 
number.
(I tested the modulo math and it works perfectly).
I moved position to here so we don't have to redeclare it in each _Piece file.

_Piece.java:
I trimmed out all the stuff I moved to Piece.java, significantly reducing the 
size of each file.
The big change is to setPiece(). All I do is if (position == 1) grid[0][0] = 1
and so on. Just those four calls, and that's it. We've already cleared the 
grid (back in rotate()) and we already updated the position (also in rotate) 
so there's nothing else to be done. Also, you'll notice that I subtracted 1 
from each of the array numbers since the first number is 0,0 not 1,1.
I also adjusted spawn() slightly by setting position = 1 and calling setPiece.
}

{
Andy - 5/19/12

-as far as i can tell all coordinates for rotates are correct and completed
}

{
Andy - 5/19/12

-completed rotates(rechecking if all grid coordinates represent what i expect)
- compiled all files successfully.

- added all pieces
-renamed SquarePiece.java - OPiece.java for consistency
}

{
Andy - 5/19/12
-made a bunch of changes to rotate functions

Piece.java- added a clearGrid() function (I'm not sure if this is necessary, 
i think we need to discuss how this movement is going to work with the square
you are monitoring, as in how do you know if something is under it? And I'm
not sure i understand the move down function)

IPiece.java - added this file so we have the I piece now, i added a system of
rotation based on changing the grid based on the current grid, the current
grid is known from a new position variable. all pieces should have the get and
set position functions( i should probably put this in Piece.java

JPiece.java - this is the big file. this shows how the rotateL and rotateR
really coexist together with the position variable. Really check this out and
see if this makes sense and in your opinion if it will work or not. I'm going
to now continue with this approach for the rest of the pieces. stop me on
Facebook if you think this approach is not worth doing.
}

{
Zach - 5/17/12
Links- these should prove invaluable:
http://tetris.wikia.com/wiki/Tetris_Guideline
http://tetris.wikia.com/wiki/TGM_Rotation

Okay, a whole bunch of changes. Tough to recall them all.

MyPanel.java:
Updated to the one I use with Yahtzee now, so that in the constructor you can 
specify what gridLayout you want (and save a bunch of lines of code while 
doing the panel setup).

Tetris.java:
Added functionality to the three buttons.
	- New game just spawns a new Tetris()
	- Pause calls pause(), which toggles the boolean 'paused' and sends the 
	  current value to the terminal.
	- Quit calls System.exit(0)
	
Piece.java:
Created this class. It's just an idea and has lots of room for changes and 
improvements. I want it to be abstract so that a lot of the same methods 
(like moving right, left, returning instance variables) can be called through 
a common interface.
The general idea is to keep track of the grid size (4 for line and square, 3 
for everything else), the lower x,y position, and then calculate everything 
else based on that.
The rest is very self explanatory and ready to be changed.

SquarePiece.java:
Definitely the easiest piece since it can't rotate.
Spawn has my idea of how that will work, and a little picture above to 
help visualize it.

GameBoard.java:
Not really sure what this should end up being, so I just threw some stuff 
in for now.
}