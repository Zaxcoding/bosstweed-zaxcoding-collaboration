{
Zach - 5/31/12

Been a little while since I've programmed at all. Whoops. Here's what I've
done so far today.

GameBoard.java:
Just fixed a single line so that it would compile. Made a silly mistake.

Tetris.java:
Put in a lot of good work on the preferences panel. I added an array of keys,
which are just ints (each filled with a KeyEvent.KeyCode), and tempKeys, and
implemented a simple 'click-the-button-then-press-the-key' way to change the
control scheme. It's simple but also pretty comprehensive since it checks for
duplicates (and won't let you save if you have them), and also prompts you to
save your changes before closing the menu if tempKeys differs from Keys.
I like it, it works very well, but I'm going to go in next and add a feedback
label so you can tell what's going on (if you aren't a dev on this game).
}

{
Zach - 5/22/12

Tetris.java:
Changed the functionality of the pause button to start at 'Start Game', then
change to 'Pause' or 'Resume' according to what it should be. 
Added a colorPieces method that should loop through and display the pieces
with their correct colors.

GameBoard.java:
Adjusted the for loop on one because it said j<y<j++.
Also, and this is pretty cool if it'll work, I changed the number we're
filling with into the big grid from 1 (for all pieces) to piece.getRGB(). My
reasoning is that once we do this we can just loop through and color all the
non-zero values of the grid, with their values. I think this should work. 

I have to go right now, I'll update this with more and also code some more 
after I work out. See ya.
}

{
Andy - 5/21/12

ok lots to tell about, not a whole lot of new code though.

Tetris.java- made the game initially paused, so that the player doesn't open up the game to a falling piece, unease = start game..

Piece.java, *Piece.java- put in a primitive version of canmoveleft and canmoveright

The big oneâ€¦
Gameboard.java- attempted to implement an idea of how i think fill should work. I put in a 6 line comment or so above my weird for loop structure thing to attempt to explain what i did. This is all off of your idea of the grid over the game board, and the way i drew it out on my paper i think it works, or does what you had in mind.Please feel free to check it out and even dismiss it if its totally wrong

My only concerns are when, in the case of the O piece, where there are 0's in the piece grid itself, i think this means the canmoveleft and canmoveright need much more logic than my initial attempt, and there is need for the contact() method for both canmoveright and fill.

it seems there is still the entire piece logic to go yet, as far as how the pieces stay in the game board, and how pieces can freely fall and coexist on a board with an arbitrary amount of pieces already on the game board.
}

{
Zach - 5/20/12
Okay, I like your ideas but I'm going to shift the direction a bit.

I'm going to make the vast majority of the work be done in Piece.java. I want
very little- mostly only spawn() and setPiece()- to be different in each
_Piece file. That way we have less to type, less lines total, and more 
importantly we can access all of the methods for the pieces just through 
a Piece variable. Then our call to rotate() will choose the correct rotate()
based on the type of the piece.
Also, remember that you don't need to use the accessors when we're working in 
_Piece files, since we have direct access to the instance variables. Those 
kinds of getPosition() and getGridSize() calls will be done from the GameBoard
or Tetris files. 

Another big change:
A lot of your pieces had an empty top row and column. From poking around the
Tetris wiki I found that only the I and O pieces require gridSize = 4, the
rest can be done with gridSize = 3. I fixed all but I and O to have gridSize 3
and adjusted them so that they work in that space.
Additionally, I subtracted 1 from each of the [3][2] combos because 2d arrays
start at 0,0 not 1,1 (my Yahtzee arrays are a little funky if that's where you
got that idea). We can change it back if you like but for now they're 
consistent.

So here's what I did:
Tetris.java:
Changed the JPiece j = new JPiece(), LPiece... to Piece j = new JPiece() etc
just to test it out. I also did a test run of rotateL() through the Piece
variable (not, for example, JPiece variable) and had no problems.

Piece.java:
Added a constructor that sets position = 1 and calls spawn().
Moved all of the rotate() calls from the individual files to here. I trimmed 
down the work that's done, all it does is clear the grid, set position to the
new position, and then call setPiece(). I also added the modulo math thing
that I had mentioned earlier so that we don't have to have four different
if(d==1) setPiece(2,..) calls, we just call setPiece(). You'll also notice
that setPiece no longer takes any arguments- I'll get to that in a bit.
I adjusted clearGrid so it does so based on the gridSize, not just a fixed 
number.
(I tested the modulo math and it works perfectly).
I moved position to here so we don't have to redeclare it in each _Piece file.

_Piece.java:
I trimmed out all the stuff I moved to Piece.java, significantly reducing the 
size of each file.
The big change is to setPiece(). All I do is if (position == 1) grid[0][0] = 1
and so on. Just those four calls, and that's it. We've already cleared the 
grid (back in rotate()) and we already updated the position (also in rotate) 
so there's nothing else to be done. Also, you'll notice that I subtracted 1 
from each of the array numbers since the first number is 0,0 not 1,1.
I also adjusted spawn() slightly by setting position = 1 and calling setPiece.
}

{
Andy - 5/19/12

-as far as i can tell all coordinates for rotates are correct and completed
}

{
Andy - 5/19/12

-completed rotates(rechecking if all grid coordinates represent what i expect)
- compiled all files successfully.

- added all pieces
-renamed SquarePiece.java - OPiece.java for consistency
}

{
Andy - 5/19/12
-made a bunch of changes to rotate functions

Piece.java- added a clearGrid() function (I'm not sure if this is necessary, 
i think we need to discuss how this movement is going to work with the square
you are monitoring, as in how do you know if something is under it? And I'm
not sure i understand the move down function)

IPiece.java - added this file so we have the I piece now, i added a system of
rotation based on changing the grid based on the current grid, the current
grid is known from a new position variable. all pieces should have the get and
set position functions( i should probably put this in Piece.java

JPiece.java - this is the big file. this shows how the rotateL and rotateR
really coexist together with the position variable. Really check this out and
see if this makes sense and in your opinion if it will work or not. I'm going
to now continue with this approach for the rest of the pieces. stop me on
Facebook if you think this approach is not worth doing.
}

{
Zach - 5/17/12
Links- these should prove invaluable:
http://tetris.wikia.com/wiki/Tetris_Guideline
http://tetris.wikia.com/wiki/TGM_Rotation

Okay, a whole bunch of changes. Tough to recall them all.

MyPanel.java:
Updated to the one I use with Yahtzee now, so that in the constructor you can 
specify what gridLayout you want (and save a bunch of lines of code while 
doing the panel setup).

Tetris.java:
Added functionality to the three buttons.
	- New game just spawns a new Tetris()
	- Pause calls pause(), which toggles the boolean 'paused' and sends the 
	  current value to the terminal.
	- Quit calls System.exit(0)
	
Piece.java:
Created this class. It's just an idea and has lots of room for changes and 
improvements. I want it to be abstract so that a lot of the same methods 
(like moving right, left, returning instance variables) can be called through 
a common interface.
The general idea is to keep track of the grid size (4 for line and square, 3 
for everything else), the lower x,y position, and then calculate everything 
else based on that.
The rest is very self explanatory and ready to be changed.

SquarePiece.java:
Definitely the easiest piece since it can't rotate.
Spawn has my idea of how that will work, and a little picture above to 
help visualize it.

GameBoard.java:
Not really sure what this should end up being, so I just threw some stuff 
in for now.
}